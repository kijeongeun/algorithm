## BOJ 2266번 "금고 테스트"
(https://www.acmicpc.net/problem/2266)

### 풀이 방법

금고를 계란으로 생각한 것 외에 Egg Dropping Dynamic Programming 과 똑같이 풀었다.
 
### 분류: Egg Dropping Dynamic Programming

**dp[계란K개][N층]** = 계란이 부서지지 않을 수 있는 최대 높은 층을 알아낼 때 계란을 떨어뜨리는 최소한의 낙하 횟수

계란을 2개 가지고 있고 건물은 총 6층이라고 하자.

**첫번째, 1개의 계란을 가지고 있을 때**

1개의 계란을 가지고 있는데 계란이 깨지는지 안깨지는지 알아보려면 1층부터 계란이 깨질때까지 층을 올라가며 계란을 떨어뜨려야 하므로 

    dp[1][j] = j

현재 까지 구한 수를 표(row: egg, col: floor) 로 표현하면 

| 구분 | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|
| 1 | 1 | 2 | 3 | 4 | 5 | 6 |
| 2 |   |   |   |   |   |   |


**두번째, 현재 가지고 있는 계란 수가 층 수보다 많으면**

    if(i > j) dp[i][j] = dp[i-1][j]

현재 까지 구한 수를 표(row: egg, col: floor) 로 표현하면 
| 구분 | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|
| 1 | 1 | 2 | 3 | 4 | 5 | 6 |
| 2 | 1 | 2 |   |   |   |   |


**세번째, 그 밖의 경우**

만약 계란 2개를 가지고 3층까지 알아보려 한다고 하자.

**1층에서 계란을 떨어뜨렸다:** 계란이 깨졌다면 답이 나온 것이므로 0, 깨지지 않았다면 계란을 그대로 가지고 (3층 - 1층)에서 떨어뜨렸을 경우 중 MAX 값을 구한다. 

**MAX값을 구하는 이유는, 최악의 상황을 가정해야 하기 때문이다.**

**(3층 - 1층) 을 하는 이유는, 1층 밑으로는 이미 떨어뜨려 봤기 때문에 볼 필요가 없기 때문.**

즉, **1층: 1 + MAX(0, 2)**

**2층에서 계란을 떨어뜨렸다:** 계란이 깨졌다면 남은 1개의 계란을 가지고 한 층 밑으로 내려간다. 깨지지 않았다면 계란을 그대로 가지고 (3층 - 2층)에서 떨어뜨렸을 경우 중 MAX값을 구한다.

즉, **2층: 1 + MAX(1, 2)** 

**3층에서 계란을 떨어뜨렸다:** 계란이 깨졌다면 남은 1개의 계란을 가지고 한 층 밑으로 내려간다. 깨지지 않았다면 현재 층이 최대 층이니까 답이 나온 것이다. 그 둘 중 MAX값을 구한다.

즉, **3층: 1 + MAX(3, 0)**

**그 중에서 다시 최소값**을 구하면 **dp[2][3]**의 값이 나온다.

그렇게 6층까지 모두 구하고 표로 표현하면

| 구분 | 1 | 2 | 3 | 4 | 5 | 6 |
|---|---|---|---|---|---|---|
| 1 | 1 | 2 | 3 | 4 | 5 | 6 |
| 2 | 1 | 2 | 2 | 3 | 3 | 3 |

그러므로 

    dp[i][j] = min(dp[i][j], 1 + max(dp[i-1][k-1], dp[i][j-k])), (k = 1 ~ j) 

---------

### 코드
```cpp
#include <iostream>
#include <algorithm>
#include <string.h>
#include <vector>
#define INF 0x7fffffff
using namespace std;

int dp[600][600]; // dp[egg][층]

int main()
{
	int n, k;
	cin >> n >> k;
	
	for (int i = 1; i <= k; i++) { // 달걀
		for (int j = 1; j <= n; j++) { // 층
			if (i == 1) {
				dp[i][j] = j;
				continue;
			}
			if (i > j) {
				dp[i][j] = dp[i - 1][j];
				continue;
			}

			dp[i][j] = INF;
			for (int k = 1; k <= j; k++) {
				dp[i][j] = min(dp[i][j], 1 + max(dp[i - 1][k - 1], dp[i][j - k]));
			}
		}
	}
	cout << dp[k][n];

	return 0;
}
```

